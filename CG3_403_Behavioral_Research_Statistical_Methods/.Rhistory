demo()
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE)
rm(list = setdiff(ls(), lsf.str()))
# Plot Normal Distributions with
#-----------------------------------------
# Same standard deviation, different mean
#-----------------------------------------
# Mean 1, sd 1
# Grid of X-axis values
x <- seq(-3, 3, 0.1)
plot(x, dnorm(x, mean = 0, sd = 1), type = "l",
ylim = c(0, 5), ylab = "", lwd = 2, col = "red")
# Mean 3, sd 1
lines(x, dnorm(x, mean = 3, sd = 1), col = "blue", lty = 1, lwd = 2)
rm(list = setdiff(ls(), lsf.str()))
# Plot Normal Distributions with
#-----------------------------------------
# Same standard deviation, different mean
#-----------------------------------------
# Mean 1, sd 1
# Grid of X-axis values
x <- seq(-3, 3, 0.1)
plot(x, dnorm(x, mean = 0, sd = 1), type = "l",
ylim = c(0, 5), ylab = "", lwd = 2, col = "red")
# Mean 3, sd 1
lines(x, dnorm(x, mean = 3, sd = 1), col = "blue", lty = 1, lwd = 2)
clear
rm(list = setdiff(ls(), lsf.str()))
# Plot Normal Distributions with
#-----------------------------------------
# Same standard deviation, different mean
#-----------------------------------------
# Mean 1, sd 1
# Grid of X-axis values
x <- seq(-3, 3, 0.1)
plot(x, dnorm(x, mean = 0, sd = 1), type = "l",
ylim = c(0, 5), ylab = "", lwd = 2, col = "red")
# Mean 3, sd 1
lines(x, dnorm(x, mean = 3, sd = 1), col = "blue", lty = 1, lwd = 2)
```{r}
```{r}
# generate 1000 trials from a normal distribution
normal.a <- rnorm( n=1000, mean=0, sd=1 )
hist( normal.a )
#next, we generate a chi-square distribution with 3 #degrees of freedom:
normal.b <- rnorm( n=1000 )  # another set of normally distributed data
normal.c <- rnorm( n=1000 )  # and another!
# Take the SUM of SQUARES of the above 3 normally distributed variables a, b, and c
chi.sq.3 <- (normal.a)^2 + (normal.b)^2 + (normal.c)^2
# and the resulting chi.sq.3 variable should contain 1000 observations that follow a chi-square distribution with 3 degrees of freedom. You can use the hist() function to have a look at these observations yourself
hist(chi.sq.3)
## Now how do we get to a t-distribution from Normal and chi-sq distributions?
# First, take a scaled chi-sq by dividing it by the degrees of freedom
scaled.chi.sq.3 <- chi.sq.3 / 3
# Then take a normally distributed variable and divide them by the square root of the scaled chi-sq variable to get a t-distribution with the same degrees of freedom
normal.d <- rnorm( n=1000 )                # yet another #set of normally distributed data
t.3 <- normal.d / sqrt( scaled.chi.sq.3 )  # divide by #square root of scaled chi-square to get t
hist (t.3)
## To get to an F distribution, take the ratio between two scaled chi-sq distributions.
# F distribution with 3 and 20 degrees of freedom:
# first take two chi-sq variables, with 3 dof and 20 dof respectively, and take the ratio:
chi.sq.20 <- rchisq( 1000, 20)                 # generate chi square data with df = 20...
scaled.chi.sq.20 <- chi.sq.20 / 20             # scale #the chi square variable...
F.3.20 <-  scaled.chi.sq.3  / scaled.chi.sq.20 # take the ratio of the two chi squares...
hist( F.3.20, freq = FALSE)                                 # ... and draw a picture
curve(df(x, 3, 20),
col="darkblue", lwd=2, add=TRUE, yaxt="n")
## The curve above confirms this looks similar if you use the R built-in function df (just like dnorm, but for the F distribution)
install.packages("tinytex")
tinytex::install_tinytex()
# Calculate the 60th %ile of the standard normal.
qnorm(0.6,0,1)
# Calculate the probability that a value lies below 0.8 in the standard normal distribution
pnorm(0.8,0,1)
# Draw 1000 samples of 30 coin tosses with p(heads) = 0.6 # and plot the distribution
# Syntax: rbinom (# observations, # trials per observation, probability of success )
hist(rbinom(1000,30,0.6))
# Do the above with only 10 trials per observation
hist(rbinom(1000,10,0.6))
# Do the above with 100 observations and 5 trials per observation
hist(rbinom(100,5,0.6))
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE)
rm(list = setdiff(ls(), lsf.str()))
# Plot Normal Distributions with
#-----------------------------------------
# Same standard deviation, different mean
#-----------------------------------------
# Mean 1, sd 1
# Grid of X-axis values
x <- seq(-3, 3, 0.1)
plot(x, dnorm(x, mean = 0, sd = 1), type = "l",
ylim = c(0, 5), ylab = "", lwd = 2, col = "red")
# Mean 3, sd 1
lines(x, dnorm(x, mean = 3, sd = 1), col = "blue", lty = 1, lwd = 2)
x <- seq(2 - 4*0.4, 2 + 4*0.4, by = 0.01)   # mean Â± 4*sd range
plot(x, dnorm(x, mean = 2, sd = 0.4),
type = "l", lwd = 2,
main = "Normal Distribution (mean=2, sd=0.4)",
xlab = "x", ylab = "Density")
q85 <- qnorm(0.85, mean = 2, sd = 0.4)
q85
p_between_1_and_2 <- pnorm(2, mean = 2, sd = 0.4) - pnorm(1, mean = 2, sd = 0.4)
p_between_1_and_2
t_sim <- rt(10000, df = 5)
hist(t_sim, breaks = 50, freq = FALSE,
main = "Simulated t-distribution (df=5)",
xlab = "t values")
curve(dt(x, df = 5), add = TRUE, lwd = 2)
install.packages("tinytex")
tinytex::install_tinytex()
tinytex::tlmgr_update()
install.packages("tinytex")
tinytex::install_tinytex()
tinytex::tlmgr_update()
tinytex::uninstall_tinytex()
install.packages("tinytex")
library(tinytex)
options(download.file.method = "libcurl")
tinytex::install_tinytex(force = TRUE)
install.packages("tinytex")
library(tinytex)
options(download.file.method = "libcurl")
tinytex::install_tinytex(force = TRUE)
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE)
t_sim <- rt(10000, df = 5)
q85 <- qnorm(0.85, mean = 2, sd = 0.4)
q85
# Open a PNG device
png("normal_mean2_sd0.4.png", width = 800, height = 600, res = 120)
x <- seq(2 - 4*0.4, 2 + 4*0.4, by = 0.01)
# Plot
plot(x, dnorm(x, mean = 2, sd = 0.4),
type = "l", lwd = 2,
main = "Normal Distribution (mean=2, sd=0.4)",
xlab = "x", ylab = "Density")
x
dev.off()
# x <- seq(2 - 4*0.4, 2 + 4*0.4, by = 0.01)
# plot(x, dnorm(x, mean = 2, sd = 0.4),
#     type = "l", lwd = 2,
#     main = "Normal Distribution (mean=2, sd=0.4)",
#     xlab = "x", ylab = "Density")
# x
# Open a PNG device
png("q1_normal_mean2_sd0.4.png", width = 800, height = 600, res = 120)
x <- seq(2 - 4*0.4, 2 + 4*0.4, by = 0.01)
# Plot
plot(x, dnorm(x, mean = 2, sd = 0.4),
type = "l", lwd = 2,
main = "Normal Distribution (mean=2, sd=0.4)",
xlab = "x", ylab = "Density")
x
dev.off()
# x <- seq(2 - 4*0.4, 2 + 4*0.4, by = 0.01)
# plot(x, dnorm(x, mean = 2, sd = 0.4),
#     type = "l", lwd = 2,
#     main = "Normal Distribution (mean=2, sd=0.4)",
#     xlab = "x", ylab = "Density")
# x
# Open PNG device
png("q4_t_distribution_df5.png", width = 800, height = 600, res = 120)
t_sim <- rt(10000, df = 5)
hist(t_sim, breaks = 50, freq = FALSE,
main = "Simulated t-distribution (df = 5)",
xlab = "t values", col = "lightgray", border = "white")
curve(dt(x, df = 5), add = TRUE, lwd = 2, col = "darkblue")
dev.off()
x <- seq(0.5, 3.5, 0.01)   # x-axis values
y <- dnorm(x, mean = 2, sd = 0.4)
plot(x, y, type = "l",
main = "Normal Distribution (mean = 2, sd = 0.4)",
xlab = "x",
ylab = "Density",
lwd = 2)
png("q1_normal_mean2_sd0.4.png", width = 800, height = 600, res = 120)
x <- seq(2 - 4*0.4, 2 + 4*0.4, by = 0.01)
# Plot
plot(x, dnorm(x, mean = 2, sd = 0.4),
type = "l", lwd = 2,
main = "Normal Distribution (mean=2, sd=0.4)",
xlab = "x", ylab = "Density")
x
dev.off()
```{# Q1: Plot a normal distribution with mean = 2 and sd = 0.4}
x <- seq(0.5, 1.0, 1.5, 2.0, 2.5, 3.5, 0.01)   # x-axis values
x <- seq(0.5, 1.5, 2.5, 3.5, 0.01)   # x-axis values
hist(t_values,
main = "Simulated t-Distribution (df = 5)",
xlab = "t values",
freq = FALSE)
t_values <- rt(1000, df = 5)   # simulate t-distribution
hist(t_values,
main = "Simulated t-Distribution (df = 5)",
xlab = "t values",
freq = FALSE)
par(mar = c(4, 4, 2, 1))   # fix margin error
t_values <- rt(1000, df = 5)
hist(t_values,
freq = FALSE,
main = "Simulated t-Distribution (df = 5)",
xlab = "t values")
t_values <- rt(1000, df = 5)
hist(t_values,
freq = FALSE,
main = "Simulated t-Distribution (df = 5)",
xlab = "t values")
# Q4: Simulated t-distribution with 5 degrees of freedom
# Set seed for reproducibility
set.seed(123)
# Simulate values from t-distribution with 5 degrees of freedom
t_vals <- rt(10000, df = 5)
# Plot the simulated t-distribution
hist(t_vals,
probability = TRUE,
breaks = 50,
col = "lightblue",
main = "Simulated t-Distribution (df = 5)",
xlab = "t values")
# Overlay the theoretical t-density
curve(dt(x, df = 5),
col = "red",
lwd = 2,
add = TRUE)
```{# Q4: Plot a simulated t-distribution with 5 degrees of freedom}
```{# Q4: Plot a simulated t-distribution with 5 degrees of freedom}
```{# Q4: Plot a simulated t-distribution with 5 degrees of freedom}
```{# Q4: Plot a simulated t-distribution with 5 degrees of freedom}
```{# Simulate t-distribution with 5 degrees of freedom}
install.packages("tinytex")
library(tinytex)
options(download.file.method = "libcurl")
tinytex::install_tinytex(force = TRUE)
install.packages("tinytex")
tinytex::install_tinytex()
tinytex::tlmgr_update()
install.packages("tinytex")
tinytex::install_tinytex()
tinytex::tlmgr_update()
install.packages("tinytex")
tinytex::install_tinytex(force = TRUE)
tinytex::is_tinytex()
tinytex::tlmgr_path()
tinytex:::tlmgr("--version")
tinytex::tlmgr_update()
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE)
t_sim <- rt(10000, df = 5)
hist(t_sim, breaks = 50, freq = FALSE,
main = "Simulated t-distribution (df = 5)",
xlab = "t values", col = "lightgray", border = "white")
curve(dt(x, df = 5), add = TRUE, lwd = 2, col = "darkblue")
x <- seq(2 - 4*0.4, 2 + 4*0.4, by = 0.01)
# Plot
plot(x, dnorm(x, mean = 2, sd = 0.4),
type = "l", lwd = 2,
main = "Normal Distribution (mean=2, sd=0.4)",
xlab = "x", ylab = "Density")
x
png("q1_normal_mean2_sd0.4.png", width = 800, height = 600, res = 120)
x <- seq(2 - 4*0.4, 2 + 4*0.4, by = 0.01)
# Plot
plot(x, dnorm(x, mean = 2, sd = 0.4),
type = "l", lwd = 2,
main = "Normal Distribution (mean=2, sd=0.4)",
xlab = "x", ylab = "Density")
x
dev.off()
x <- seq(2 - 4*0.4, 2 + 4*0.4, by = 0.01)
# Plot
plot(x, dnorm(x, mean = 2, sd = 0.4),
type = "l", lwd = 2,
main = "Normal Distribution (mean=2, sd=0.4)",
xlab = "x", ylab = "Density")
x
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE)
rm(list = setdiff(ls(), lsf.str()))
# Vectors and Factors
# Create a vector as input.
data <- c("East","West","East","North","North","East","West","West","West","East","North")
print(data)
print(is.factor(data))
# Apply the factor function.
factor_data <- factor(data)
print(factor_data)
print(is.factor(factor_data))
# From Mariam Aly's tutorial
##############################################################################
## Factors
##############################################################################
# A factor is a vector object used to specify a discrete classification (grouping) of the components of other vectors of the same length.
# can be ordered or unordered
## Example for 'ragged arrays', which can have subclasses of different sizes
# say you have 6 subjects and 3 conditions in your experiment
# this is a list of the condition that each subject took part in
condition=c('faces','scenes','objects','faces','scenes','objects')
# can create a factor for condition
conditionf=factor(condition) #use the factor() function
# print to screen
print(conditionf)
# produces:
# faces   scenes  objects faces   scenes  objects
# Levels: faces objects scenes
# can ask specifically for the levels of the factor
levels(conditionf) # returns "faces"   "objects" "scenes"
# you can then use the tapply() function to calculate things like the mean for a variable you have for each of your factors
# continued from above
accuracy=c(90,88,72,84,81,94) # accuracy for each of you 6 subjects, in the same order in which you input the conditions (i.e. f,s,o,f,s,o)
# now calculate the mean accuracy for each condition using tapply()
# this function takes this form: tapply(data,factor/index variable,function), where factor/index is the factor variable you created and function is what you want to do on the data
# so if you want to see mean age for males and females, data=age, factor/index=gender, function=mean
# looks at data in the first variable as a function of different levels of the second variable
# note that tapply() will work even if the second argument is not a factor, because the argument will be coerced into a factor when necessary (using as.factor())
# e.g. calculate the mean
condaccmeans=tapply(accuracy,conditionf,mean)
print(condaccmeans)
# returns :
# faces objects  scenes
# 87.0    83.0    84.5
# would work if you use tapply(accuracy,condition,mean) because condition would be coerced into a factor
# The function tapply() is used to apply a function, here mean(), to each group  of components of the first argument, here accuracy, defined by the levels of the second component,here conditionf, as if they were separate vector structures. The result is a structure of the same length as the levels attribute of the factor containing the results.
View(cars)
summary(cars)
plot(cars)
# Q1: what do you think is the relationship between speed and stopping distance based on the scatterplot? +, -, or no relationship? (use the plot function)
#
# Q2: plot a histogram of car speeds (use hist)
# Q3: what is the most frequent stopping distance in this dataset (an approx bin of distances is fine)?
# Grid of X-axis values
x <- seq(-4, 4, 0.1)
#-----------------------------------------
# Same standard deviation, different mean
#-----------------------------------------
# Mean 0, sd 1
plot(x, dnorm(x, mean = 1, sd = 0.1), type = "l",
ylim = c(0, 10), ylab = "", lwd = 2, col = "red")
# Mean 3, sd 1
lines(x, dnorm(x, mean = 3, sd = 1), col = "blue", lty = 1, lwd = 2)
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE)
